use std::convert::TryInto;

use bech32::{ToBase32, Variant};
use cosmwasm_std::{Api, StdError, StdResult};
use hex;
use ripemd::Ripemd160;
use sha2::{digest::Update, Digest, Sha256};

/// Generate the address corresponding to the pubkey and prefix
///
/// NOTE: Here `pubkey` shall be a hex-encoded bytearray.
///
/// NOTE: Raw address is generated by `ripemd160(sha256(pk_bytes))[:20]` according to ADR-028:
/// https://docs.cosmos.network/master/architecture/adr-028-public-key-addresses.html
pub fn pubkey_to_addr(pubkey: &str, prefix: &str) -> StdResult<String> {
    let pk_bytes =
        hex::decode(pubkey).map_err(|err| wrap_err("[hex] failed to decode pubkey", err))?;

    let pk_hash_bytes = Sha256::new().chain(pk_bytes).finalize();
    let pk_hash_bytes = Ripemd160::new().chain(pk_hash_bytes).finalize();

    bech32::encode(prefix, pk_hash_bytes.to_base32(), Variant::Bech32)
        .map_err(|err| wrap_err("[bech32] failed to generate address", err))
}

/// Verify a secp256k1 signature
///
/// NOTE: Here `pubkey` and `signature` shall be hex-encoded bytearrays
///
/// NOTE: We assume the signature was for the SHA256 hash of the signature
pub fn verify_signature(
    api: &dyn Api,
    msg: &str,
    pubkey: &str,
    signature: &str,
) -> StdResult<bool> {
    let msg_hash_bytes = Sha256::new().chain(msg).finalize();

    let sig_bytes =
        hex::decode(signature).map_err(|err| wrap_err("[hex] failed to decode signature", err))?;
    let pk_bytes =
        hex::decode(pubkey).map_err(|err| wrap_err("[hex] failed to decode pubkey", err))?;

    api.secp256k1_verify(&msg_hash_bytes, &sig_bytes, &pk_bytes)
        .map_err(|err| wrap_err("[secp256k1] failed to verify signature", err))
}

/// Verify a merkle proof
///
/// NOTE: Here `merkle_proof` and `merkle_hash` shall be a hex-encoded bytearray
///
/// NOTE: We assume the leaves are SHA256 hashes of the leaf strings
pub fn verify_proof(leaf: &str, merkle_root: &str, merkle_proof: &[String]) -> StdResult<bool> {
    let hash = sha2::Sha256::digest(leaf.as_bytes())
        .as_slice()
        .try_into()
        .map_err(|_| StdError::generic_err("[merkle] hash of leaf is of wrong length"))?;

    let hash = merkle_proof.iter().try_fold(hash, |hash, p| {
        let proof_bytes: [u8; 32] = hex::decode(p)
            .map_err(|err| wrap_err("[hex] failed to decode merkle proof", err))?
            .try_into()
            .map_err(|_| StdError::generic_err("[merkle] proof is of wrong length"))?;

        let hashes = if hash < proof_bytes {
            [hash, proof_bytes]
        } else {
            [proof_bytes, hash]
        };

        sha2::Sha256::digest(hashes.concat())
            .as_slice()
            .try_into()
            .map_err(|_| StdError::generic_err("[merkle] hash is of wrong length"))
    })?;

    let root_hash: [u8; 32] = hex::decode(merkle_root)
        .map_err(|err| wrap_err("[hex] failed to decode merkle root", err))?
        .try_into()
        .map_err(|_| StdError::generic_err("[merkle] root is of wrong length"))?;

    Ok(root_hash == hash)
}

/// Wrap an error into a `cosmwasm_std::StdError`, assuming the error type implements `ToString`
pub fn wrap_err<T: ToString>(prefix: &str, err: T) -> StdError {
    StdError::generic_err(format!("{}: {}", prefix, err.to_string()))
}
